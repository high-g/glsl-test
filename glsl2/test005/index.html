<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>test</title>
<style>
* {
  padding: 0;
  margin: 0;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script src="../lib/minMatrix.js"></script>
<script id="vs" type="x-shader/x-vertex">
attribute vec3 position;

void main(void) {
  gl_Position = vec4(position, 1.0);
}
</script>
<script id="fs" type="x-shader/x-fragment">
precision mediump float;
uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;

void main(void) {
	vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);
	vec2 color = (vec2(1.0) + p.xy) * 0.5;
	gl_FragColor = vec4(color, 0.0, 1.0);
}
</script>
<script>
// global
var c, cw, ch, mx, my, gl;
var startTime = new Date().getTime();
var time = 0.0;
var tempTime = 0.0;
var uniLocation = [];

// canvas エレメントを取得
c = document.getElementById('canvas');

// canvas サイズ
cw = 512; ch = 512;
c.width = cw; c.height = ch;

// WebGL コンテキストを取得
gl = c.getContext('webgl') || c.getContext('experimental-webgl');

// シェーダ周りの初期化
var prg = create_program(create_shader('vs'), create_shader('fs'));
uniLocation[0] = gl.getUniformLocation(prg, 'time');
uniLocation[1] = gl.getUniformLocation(prg, 'mouse');
uniLocation[2] = gl.getUniformLocation(prg, 'resolution');

// 頂点データ回りの初期化
var position = [
  -1.0,  1.0,  0.0,
  1.0,  1.0,  0.0,
  -1.0, -1.0,  0.0,
  1.0, -1.0,  0.0
];
var index = [
  0, 2, 1,
  1, 2, 3
];
var vPosition = create_vbo(position);
var vIndex = create_ibo(index);
var vAttLocation = gl.getAttribLocation(prg, 'position');
gl.bindBuffer(gl.ARRAY_BUFFER, vPosition);
gl.enableVertexAttribArray(vAttLocation);
gl.vertexAttribPointer(vAttLocation, 3, gl.FLOAT, false, 0, 0);
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vIndex);

// その他の初期化
gl.clearColor(0.0, 0.0, 0.0, 1.0);
mx = 0.5; my = 0.5;

// レンダリング関数呼出
render();

// レンダリングを行う関数
function render(){
  // 時間管理
  time = (new Date().getTime() - startTime) * 0.001;

  // カラーバッファをクリア
  gl.clear(gl.COLOR_BUFFER_BIT);

  // uniform 関連
  gl.uniform1f(uniLocation[0], time + tempTime);
  gl.uniform2fv(uniLocation[1], [mx, my]);
  gl.uniform2fv(uniLocation[2], [cw, ch]);

  // 描画
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
  gl.flush();

  // 再帰
  requestAnimationFrame(render);
}

// シェーダを生成する関数
function create_shader(id){
  // シェーダを格納する変数
  var shader;

  // HTMLからscriptタグへの参照を取得
  var scriptElement = document.getElementById(id);

  // scriptタグが存在しない場合は抜ける
  if(!scriptElement){return;}

  // scriptタグのtype属性をチェック
  switch(scriptElement.type){

    // 頂点シェーダの場合
    case 'x-shader/x-vertex':
      shader = gl.createShader(gl.VERTEX_SHADER);
      break;

    // フラグメントシェーダの場合
    case 'x-shader/x-fragment':
      shader = gl.createShader(gl.FRAGMENT_SHADER);
      break;
    default :
      return;
  }

  // 生成されたシェーダにソースを割り当てる
  gl.shaderSource(shader, scriptElement.text);

  // シェーダをコンパイルする
  gl.compileShader(shader);

  // シェーダが正しくコンパイルされたかチェック
  if(gl.getShaderParameter(shader, gl.COMPILE_STATUS)){

    // 成功していたらシェーダを返して終了
    return shader;
  }else{

    // 失敗していたらエラーログをアラートしコンソールに出力
    alert(gl.getShaderInfoLog(shader));
    console.log(gl.getShaderInfoLog(shader));
  }
}

// プログラムオブジェクトを生成しシェーダをリンクする関数
function create_program(vs, fs){
  // プログラムオブジェクトの生成
  var program = gl.createProgram();

  // プログラムオブジェクトにシェーダを割り当てる
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);

  // シェーダをリンク
  gl.linkProgram(program);

  // シェーダのリンクが正しく行なわれたかチェック
  if(gl.getProgramParameter(program, gl.LINK_STATUS)){

    // 成功していたらプログラムオブジェクトを有効にする
    gl.useProgram(program);

    // プログラムオブジェクトを返して終了
    return program;
  }else{

    // 失敗していたら NULL を返す
    return null;
  }
}

// VBOを生成する関数
function create_vbo(data){
  // バッファオブジェクトの生成
  var vbo = gl.createBuffer();

  // バッファをバインドする
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);

  // バッファにデータをセット
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);

  // バッファのバインドを無効化
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // 生成した VBO を返して終了
  return vbo;
}

// IBOを生成する関数
function create_ibo(data){
  // バッファオブジェクトの生成
  var ibo = gl.createBuffer();

  // バッファをバインドする
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);

  // バッファにデータをセット
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);

  // バッファのバインドを無効化
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

  // 生成したIBOを返して終了
  return ibo;
}

const c = document.getElementById('canvas')
const gl = c.getContext('webgl')
const cw = 512
const ch = 512
const mx = 0.5
const my = 0.5
const uniLocation = []
const startTime = new Date().getTime()
let prg

const init = () => {
  c.width = cw
  c.height = ch

  prg = create_program(create_shader('vs'), create_shader('fs'))
  uniLocation[0] = gl.getUniformLocation(prg, 'time')
  uniLocation[1] = gl.getUniformLocation(prg, 'mouse')
  uniLocation[2] = gl.getUniformLocation(prg, 'resolution')

  const position = [
    -1.0,  1.0,  0.0,
     1.0,  1.0,  0.0,
    -1.0, -1.0,  0.0,
     1.0, -1.0,  0.0
  ]

  const index = [
    0, 2, 1,
    1, 2, 3
  ]

  const vPosition = create_vbo(position)
  const vIndex = create_ibo(index)
  const vAttLocation = gl.getAttribLocation(prg, 'position')
  gl.bindBuffer(gl.ARRAY_BUFFER, vPosition)
  gl.enableVertexAttribArray(vAttLocation)
  gl.vertexAttribPointer(vAttLocation, 3, gl.FLOAT, false, 0, 0)
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vIndex)
  gl.clearColor(0.0, 0.0, 0.0, 1.0)
  render()
}

const create_shader = (id) => {
  let shader
  const scriptElement = document.getElementById(id)

  switch(scriptElement.type) {
    case 'x-shader/x-vertex':
      shader = gl.createShader(gl.VERTEX_SHADER)
      break
    case 'x-shader/x-fragment':
      shader = gl.createShader(gl.FRAGMENT_SHADER)
      break
    default:
      return
  }

  gl.shaderSource(shader, scriptElement.text)
  gl.compileShader(shader)
  if(gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    return shader
  } else {
    alert(gl.getShaderInfoLog(shader))
  }
}

const create_program = (vs, fs) => {
  // プログラムオブジェクト生成
  const program = gl.createProgram()

  // プログラムオブジェクトにシェーダを割り当てる
  gl.attachShader(program, vs)
  gl.attachShader(program, fs)

  // シェーダをリンク
  gl.linkProgram(program)

  if(gl.getProgramParameter(program, gl.LINK_STATUS)) {
    gl.useProgram(program)
    return program
  } else {
    alert(gl.getShaderInfoLog(program))
  }
}

const create_vbo = (data) => {
  // バッファオブジェクト生成
  const vbo = gl.createBuffer()
  // バッファをバインド
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo)
  // バッファにデータセット
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
  // バッファのバインドを無効化
  gl.bindBuffer(gl.ARRAY_BUFFER, null)
  return vbo
}

const create_ibo = (data) => {
  const ibo = gl.createBuffer()
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo)
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW)
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
  return ibo
}

const render = () => {
  // 時間管理
  const time = (new Date().getTime() - startTime) * 0.001
  // カラーバッファクリア
  gl.clear(gl.COLOR_BUFFER_BIT)
  // uniform関連
  gl.uniform1f(uniLocation[0], time)
  gl.uniform2fv(uniLocation[1], [mx, my])
  gl.uniform2fv(uniLocation[2], [cw, ch])
  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0)
  gl.flush()
  requestAnimationFrame(render)
}

init()
</script>
</body>
</html>